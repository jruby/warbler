/**
 * Copyright (c) 2010-2012 Engine Yard, Inc.
 * Copyright (c) 2007-2009 Sun Microsystems, Inc.
 * This source code is available under the MIT license.
 * See the file LICENSE.txt for details.
 */

import java.lang.reflect.Method;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.SequenceInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URI;
import java.net.URLClassLoader;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.Map;
import java.util.jar.JarEntry;

import java.io.IOException;

public class ExplodedWarMain {
    static final String WEBSERVER_PROPERTIES = "/WEB-INF/webserver.properties";
    static final String WEBSERVER_JAR = "/WEB-INF/webserver.jar";
    static final String WEBSERVER_CONFIG = "/WEB-INF/webserver.xml";

    // Shell arguments
    private final String[] arguments;

    // The root of the exploded war archive
    private File warRoot;

    // The root of the project within the war
    private File webRoot;

    // An instance of Jruby scripting container used to run the application
    private Object jruby;
    private Object rubyInstanceConfig;

    //----------------------------------------------------------------------------------------------
    // Constructor getting args from the system
    ExplodedWarMain(String[] arguments) throws IOException {
        this.arguments = arguments;

        this.warRoot = new File(new File("./lib/war").getCanonicalPath());
        debug("War root: " + warRoot.toString());

        this.webRoot = new File(warRoot, "/WEB-INF/");
        debug("Web root: " + webRoot.toString());
    }

    //----------------------------------------------------------------------------------------------
    // FIXME: Catch and log any exceptions to console
    public static void main(String[] args) throws Exception {
        ExplodedWarMain main = new ExplodedWarMain(args);
        System.exit(main.start());
    }

    protected int start() throws Exception {
        final List<String> argsList = Arrays.asList(arguments);
        final int sIndex = argsList.indexOf("-S");

        if (sIndex == -1) {
            debug("No command specified, starting a web server");
            launchWebServer();
            return 0;
        }

        String[] arguments = argsList.subList(0, sIndex).toArray(new String[0]);
        String execArg = argsList.get(sIndex + 1);
        String[] executableArgv = argsList.subList(sIndex + 2, argsList.size()).toArray(new String[0]);
        return launchCommand(execArg, executableArgv);
    }

    //----------------------------------------------------------------------------------------------
    private int launchCommand(String command, String[] commandArgs) throws Exception {
        if (command.equals("rails")) {
            // The rails executable doesn't play well with ScriptingContainer, so we've packaged the
            // same script that would have been generated by `rake rails:update:bin`
            command = "/../META-INF/rails.rb";
        } else {
            System.out.println("Only -S rails is supported for now");
            return 1;
        }

        debug("Initializing JRuby scripting environment...");
        initJRubyContainer(commandArgs);

        debug("Launching jruby with command '" + command + "' and arguments: " + Arrays.toString(commandArgs));
        return launchJRubyCommand(command, commandArgs);
    }

    //----------------------------------------------------------------------------------------------
    protected int launchJRubyCommand(String command, String args[]) throws Exception {
        // Find the path for the file to execute for the given command
        final File commandFile = new File(webRoot, command);
        debug("locating script: " + commandFile);
        if (!commandFile.exists()) {
            throw new IllegalStateException("Failed to locate the command file: '" + commandFile + "'");
        }
        final String executablePath = commandFile.getAbsolutePath();

        // Set the executable file and process arguments on jruby
        invokeMethod(jruby, "setScriptFilename", executablePath);
        invokeMethod(rubyInstanceConfig, "processArguments", (Object) args);

        // Generate a ruby script that prepares the environment for executing ruby scripts
        final CharSequence execScriptEnvPre = executableScriptEnvPrefix();

        // Load the command script and prepend it with the initialization code
        debug("Loading command script: " + executablePath);
        Object executableInput = new SequenceInputStream(
            new ByteArrayInputStream(execScriptEnvPre.toString().getBytes()),
            (InputStream) invokeMethod(rubyInstanceConfig, "getScriptSource")
        );

        // Finally, ask jruby to execute the script
        Object runtime = invokeMethod(jruby, "getRuntime");

        debug("invoking " + executablePath + " with: " + Arrays.toString(args));
        Object outcome = invokeMethod(runtime, "runFromMain",
            new Class[] { InputStream.class, String.class },
            executableInput,
            executablePath
        );

        /// Cast the result of the script into an exit code
        return (outcome instanceof Number) ? ((Number) outcome).intValue() : 0;
    }

    //----------------------------------------------------------------------------------------------
    static void debug(String message) {
        System.out.println(message);
    }

    //----------------------------------------------------------------------------------------------
    static String getSystemProperty(final String name) {
        return getSystemProperty(name, null);
    }

    static String getSystemProperty(final String name, final String defaultValue) {
        try {
            return System.getProperty(name, defaultValue);
        }
        catch (SecurityException e) {
            return defaultValue;
        }
    }

    static boolean setSystemProperty(final String name, final String value) {
        try {
            System.setProperty(name, value);
            return true;
        }
        catch (SecurityException e) {
            return false;
        }
    }

    static String getENV(final String name) {
        return getENV(name, null);
    }

    static String getENV(final String name, final String defaultValue) {
        try {
            if ( System.getenv().containsKey(name) ) {
                return System.getenv().get(name);
            }
            return defaultValue;
        }
        catch (SecurityException e) {
            return defaultValue;
        }
    }

    //----------------------------------------------------------------------------------------------
    protected static Object invokeMethod(final Object self, final String name, final Object... args) throws NoSuchMethodException, IllegalAccessException, Exception {
        final Class[] signature = new Class[args.length];
        for ( int i = 0; i < args.length; i++ ) {
            signature[i] = args[i].getClass();
        }
        return invokeMethod(self, name, signature, args);
    }

    //----------------------------------------------------------------------------------------------
    protected static Object invokeMethod(final Object self, final String name, final Class[] signature, final Object... args) throws NoSuchMethodException, IllegalAccessException, Exception {
        Method method = self.getClass().getDeclaredMethod(name, signature);
        try {
            return method.invoke(self, args);
        } catch (InvocationTargetException e) {
            Throwable target = e.getTargetException();
            if (target instanceof Exception) {
                throw (Exception) target;
            }
            throw e;
        }
    }

    //----------------------------------------------------------------------------------------------
    protected CharSequence executableScriptEnvPrefix() {
        final String gemsDir = new File(webRoot, "gems").getAbsolutePath();
        final String gemfile = new File(webRoot, "Gemfile").getAbsolutePath();
        System.out.println("setting GEM_HOME to " + gemsDir);
        System.out.println("... and BUNDLE_GEMFILE to " + gemfile);

        // ideally this would look up the config.override_gem_home setting
        return (
            "ENV['GEM_HOME'] = ENV['GEM_PATH'] = '"+ gemsDir +"' \n" +
            "ENV['BUNDLE_GEMFILE'] ||= '"+ gemfile +"' \n" +
            "require '" + webRoot + "/../META-INF/init.rb'"
        );
    }

    //----------------------------------------------------------------------------------------------
    protected void initJRubyContainer(String[] commandArgs) throws Exception {
        final URL[] jars = loadJarUrls(webRoot);
        this.jruby = newScriptingContainer(jars);

        invokeMethod(jruby, "setArgv", (Object) commandArgs);
        debug("setArgv: " + Arrays.toString(commandArgs));

        String rootPath = webRoot.getAbsolutePath();
        invokeMethod(jruby, "setCurrentDirectory", rootPath);
        debug("setCurrentDirectory: " + rootPath);

        invokeMethod(jruby, "setHomeDirectory", "uri:classloader:/META-INF/jruby.home");

        // for some reason, the container needs to run a scriptlet in order for it
        // to be able to find the gem executables later
        invokeMethod(jruby, "runScriptlet", "SCRIPTING_CONTAINER_INITIALIZED=true");

        // Allow ruby to modify the environment
        final Object provider = invokeMethod(jruby, "getProvider");
        this.rubyInstanceConfig = invokeMethod(provider, "getRubyInstanceConfig");
        invokeMethod(rubyInstanceConfig, "setUpdateNativeENVEnabled", new Class[] { Boolean.TYPE }, false);
    }

    //----------------------------------------------------------------------------------------------
    private Properties getWebserverProperties(File root) throws Exception {
        Properties props = new Properties();
        try {
            InputStream is = getClass().getResourceAsStream(WEBSERVER_PROPERTIES);
            if ( is != null ) props.load(is);
        } catch (Exception e) { }

        String port = getSystemProperty("warbler.port", getENV("PORT"));
        port = port == null ? "8080" : port;
        String host = getSystemProperty("warbler.host", "0.0.0.0");
        String webserverConfig = getSystemProperty("warbler.webserver_config", getENV("WARBLER_WEBSERVER_CONFIG"));
        String embeddedWebserverConfig = new URI("jar", new File(root, WEBSERVER_CONFIG).getCanonicalPath(), null).toURL().toString();
        webserverConfig = webserverConfig == null ? embeddedWebserverConfig : webserverConfig;
        for ( Map.Entry entry : props.entrySet() ) {
            String val = (String) entry.getValue();
            val = val.replace("{{warfile}}", root.getAbsolutePath()).
                      replace("{{port}}", port).
                      replace("{{host}}", host).
                      replace("{{config}}", webserverConfig).
                      replace("{{webroot}}", root.getAbsolutePath());
            entry.setValue(val);
        }

        if (props.getProperty("props") != null) {
            String[] propsToSet = props.getProperty("props").split(",");
            for ( String key : propsToSet ) {
                setSystemProperty(key, props.getProperty(key));
            }
        }

        return props;
    }

    //----------------------------------------------------------------------------------------------
    public void launchWebServer() throws Exception {
        // Find the Jetty jar file
        File jarFile = new File(webRoot, "webserver.jar");
        debug("webserver.jar is at" + jarFile.getPath());

        // Load Jetty
        URLClassLoader loader = new URLClassLoader(new URL[] {jarFile.toURI().toURL()});
        Thread.currentThread().setContextClassLoader(loader);

        // Get the name of the main jetty class
        Properties props = getWebserverProperties(webRoot);
        String mainClass = props.getProperty("mainclass");
        if (mainClass == null) {
            throw new IllegalArgumentException("Unknown webserver main class (" + WEBSERVER_PROPERTIES + " is missing 'mainclass' property)");
        }

        // Get the jetty class object based on its name
        Class<?> klass = Class.forName(mainClass, true, loader);
        Method main = klass.getDeclaredMethod("main", new Class[] { String[].class });

        // Start jetty
        String[] newArgs = {}; // launchWebServerArguments(props);
        debug("invoking webserver with: " + Arrays.deepToString(newArgs));
        main.invoke(null, new Object[] { newArgs });
    }

    //----------------------------------------------------------------------------------------------
    // Finds all jar files in the lib directory of the project and returns them as an array
    public static URL[] loadJarUrls(File root) throws Exception {
        List<URL> jars = new ArrayList<URL>();

        File[] files = new File(root, "lib").listFiles();

        for (File f : files) {
          if (f.isFile() && f.getName().endsWith(".jar"))
            jars.add(f.toURI().toURL());
        }
        return jars.toArray(new URL[jars.size()]);
    }

    //----------------------------------------------------------------------------------------------
    protected static Object newScriptingContainer(final URL[] jars) throws Exception {
        setSystemProperty("org.jruby.embed.class.path", "");

        URLClassLoader classLoader = new URLClassLoader(jars);
        Class scriptingContainerClass = Class.forName("org.jruby.embed.ScriptingContainer", true, classLoader);
        Object jruby = scriptingContainerClass.newInstance();

        debug("scripting container class loader urls: " + Arrays.toString(jars));
        invokeMethod(jruby, "setClassLoader", new Class[] { ClassLoader.class }, classLoader);

        return jruby;
    }
}
